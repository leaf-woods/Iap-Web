#include <cassert>
#include <chrono>
#include <iostream>

#include "region_builder.h"
#include "region_constants.h"

using namespace std;

/*
 * @20250912
 * A region has a property desc to indicate what is the region, e.g. the region is 
 * sky on the photo.
 */
 /// TODO test smallest region which is one pixel
 /*
  * @20250916
  * A region_builder builds regions using the image matrix according to the region desc.
  */
region_builder::region_builder() {
    init();
    sta = new bool_status(status::NORMAL, false);
}

region_builder::~region_builder() {
    logger->info("Destruct region builder.");
    clear();
    exp = nullptr;
    mbounds = nullptr;
    evaluator = nullptr;
    po = nullptr;
    printer = nullptr;
    prov = nullptr;
    logger = nullptr;
    sexp = nullptr;
    delete sta;
    sta = nullptr;
}

/*
 * Since region is reusable, clear() is not only called by destructor.
 */
void region_builder::clear() {
    if (sta != nullptr) {
        sta->clear();
    }
    
    // Just cleared.
    if (cols_map == nullptr || rows_map == nullptr || cols == nullptr || rows == nullptr) {
        return;
    }
    
    // Just created.
    if (cols_map->size()==0 && rows_map->size()==0 && cols->size()==0 && rows->size()==0) {
        delete cols_map; 
        cols_map = nullptr;
        delete rows_map; 
        rows_map = nullptr;
        delete cols; 
        cols = nullptr;
        delete rows; 
        rows = nullptr;
        assert(dv!=nullptr && dv->size()==0);
        delete dv;
        dv = nullptr;
        assert(bv!=nullptr && bv->size()==0);
        delete bv;
        bv = nullptr;
        return;
    }

    // Just used.
    if (cols_map->size()>0) {
        clearMap(*cols_map);
    }
    *cols_map = map<int, std::vector<int*>*>();
    delete cols_map;
    cols_map = nullptr;

    if (rows_map->size()>0) {
        clearMap(*rows_map);
    }
    *rows_map = map<int, std::vector<int*>*>();
    delete rows_map;
    rows_map = nullptr;

    if (dv->size() > 0) {
        clearVector(*dv);
    }
    delete dv;
    dv = nullptr;

    if (bv->size() > 0) {
        bv->clear();
        *bv = vector<border_pixel_diff_node*>();
    }
    delete bv;
    bv = nullptr;

    //https://stackoverflow.com/questions/56688963/how-to-free-the-memory-occupied-by-a-queuestl
    if (cols->size()>0) {
        logger->error("Queue cols is not empty. Size: ", cols->size());
        cols->clear();
        deque<span_node*>().swap(*cols);
    }
    if (rows->size()>0) {
        logger->error("Queue rows is not empty. Size: ", rows->size());
        rows->clear();
        deque<span_node*>().swap(*rows);
    }
    delete rows;
    rows = nullptr;
    delete cols;
    cols = nullptr;
}

/*
 * vector<int*>: int* not generated by new.
 */
void region_builder::clearMap(map<int, vector<int*>*>& m) {
    if (m.size()>0) {
        vector<int*>* v;
        for (auto it=m.begin(); it!=m.end();) {
            v = it->second;
            v->clear(); 
            *v = vector<int*>();
            it = m.erase(it);
            delete v;
        }
    }
}

void region_builder::countRegionPixels() {
    if (rows_map->size()==0 || cols_map->size()==0) {
        assert(cols_map->size()==rows_map->size());
        logger->info("Map is empty.");
        return;
    }
    count = 0;
    //if (rows_map->size() < cols_map->size()) {
        // https://en.cppreference.com/w/cpp/container/map.html
        for (const auto& [key, value] : *rows_map) {
            count+=countVector(*value);
        }
        
    //}
    
    //else {
        int count2 = 0;
        for (const auto& [key, value] : *cols_map) {
            count2+=countVector(*value);
        }
    //}
    cout << "rows map count: " << count << " cols map count: " << count2 << endl;     
    logger->debug("size: ", count);
}

int region_builder::countVector(const vector<int*>& v) {
    int ct = 0;
    for (int i=0; i<v.size(); i++) {
        ct+=v.at(i)[1] - v.at(i)[0] + 1;
    }
    return ct;
}

void region_builder::init() {
    count = 0;
    count_internal = 0;
    rows = new deque<span_node*>();
    cols = new deque<span_node*>();

    rows_map = new map<int, vector<int*>*>();
    cols_map = new map<int, vector<int*>*>();
    dv = new vector<int*>();

    bv = new vector<border_pixel_diff_node*>();
}

/*
 * @20250915 Reuse region.
 * Precondition: deque cols and rows, map cols_map and rows_map are newly created instances.
 */
 // In java, we use iexplore as a type. We convert iexplore to its impl at runtime.
 // This means, builder#explore() will provide a paramter that injects the explore type into 
 // builder class. That is to say, we will put policy logic somewhere else and the explore type
 // will be determined before calling method explore().
 // We want to find a way to try different policies easily.
void region_builder::explore(cv::Mat& mat, int row, int col, int start_direction) {
    if (mat.rows <= 0 || mat.cols <= 0) {
        logger->info("Invalid matrix.");
        return;
    }
    if (row < 0 || row >= mat.rows) {
        logger->info("Row out of bound: ", row);
        return;
    }
    if (col < 0 || col >= mat.cols) {
        logger->info("Col out of bound: ", col);
        return;
    }

    assert(po->getPolicy() != Policies::na);
    logger->info("Explore: ", po->getPolicyVal());

    sta->clear();

    start = evaluator->evaluatePixelColor(*po, mat.at<cv::Vec3b>(row, col));
    logger->info("Start pixel desc: ", region_desc::toString(start));
    
    if (po->getPolicy() == Policies::r_desc) {
        if ( start != po->getRegionDesc()) {
            logger->finfo("snsnsv", "Pixel not in region: row: ", row, " col: ", col, " for: ", po->getPolicyVal());
            return;
        }
    }
    
    // Just cleared.
    if (cols_map == nullptr || rows_map == nullptr) {
        assert(cols == nullptr && rows == nullptr);
        init();
    }
    // Just used.
    else if (cols_map->size()>0 || rows_map->size()>0) {
        assert(cols->size()==0 || rows->size()==0);
        clear();
        init(); 
    }
    
    /// TODO
    H = mat.rows;
    W = mat.cols;
    mbounds->setOH(H);
    mbounds->setOW(W);
    
    auto t1 = chrono::high_resolution_clock::now();

    exp->setEvalPolicy(po);
    exp->setStartPixelRegionDesc(start);
    if (start_direction == region_constants::VERTICAL) {
        exp->explore(mat, row, col, *rows, *cols, *rows_map, *cols_map);
    }
    else if (start_direction == region_constants::HORIZONTAL) {
        exp->explore_r(mat, row, col, *rows, *cols, *rows_map, *cols_map);
    }
    else {
        logger->error("Invalid direction: ", start_direction);
        return;
    }
    
    //logger->fdebug("snsnsn", "count: ", count, " count col: ", count_exp_col, " count row: ", count_exp_row);

    rpt->printMap("cols", *cols_map);
    rpt->printMap("rows", *rows_map);
    countRegionPixels();
    cout << "size: " << size() << endl;

    exp->explore_diag(mat, dv);
    
    auto t2 = chrono::high_resolution_clock::now();
    logger->info("Total process time: ", (int)chrono::duration_cast<chrono::microseconds>(t2-t1).count());
}

void region_builder::computeBorders(const cv::Mat& mat) {
    logger->info("Compute borders.");
    auto t1 = chrono::high_resolution_clock::now();
    getAllBorderPixels(mat);
    cout << "internal: " << count_internal << endl;
    rpt->printBorderPixelsDiff(*bv);
    auto t2 = chrono::high_resolution_clock::now();
    logger->info("Total process time: ", (int)chrono::duration_cast<chrono::microseconds>(t2-t1).count());
}

void region_builder::setLogger(iapcv_log* logger) {
    this->logger = logger;
}

void region_builder::setLogLevel(int level) {
    this->logger->setLevel(level);
}

void region_builder::setPrint(iap_print* print) {
    this->printer = print;
}

void region_builder::setEvalPolicy(eval_policy* po) {
    this->po = po;
}

void region_builder::setRegionEvaluator(region_evaluator* eval) {
    this->evaluator = eval;
}

void region_builder::setRegionExplore(region_explore* exp) {
    this->exp = exp;
}

void region_builder::setRegionPrint(region_print* p) {
    this->rpt = p;
}

int region_builder::size() {
    return count;
}

void region_builder::setMatrixBounds(matrix_bounds* mb) {
    this->mbounds = mb;
}

void region_builder::setSubMatrix(int r, int c, int num_rs, int num_cs) {
    mbounds->setSubMatrix(r, c, num_rs, num_cs);
}

void region_builder::useMatrix() {
    mbounds->useMatrix();
}

bool region_builder::getNextStartPoint(size_t s, int* pixel) {
    assert(s==2 && pixel != nullptr);
    if (rows_map == nullptr) {
        logger->error("Map is null.");
        return false;
    }
    if (rows_map->size() == 0) {
        logger->error("Map is empty.");
        return false;
    }
    int count = 0; 
    for (auto it=rows_map->begin(); it!=rows_map->end(); it++) {
        if (it->second->at(0)[0] >= 1) {
                pixel[0] = count; pixel[1] = it->second->at(0)[0] - 1;
                logger->fdebug("snsns", "Found at [", pixel[0], ", ", pixel[1], "]");
                return true;
        }
        if (it->second->at(0)[1] <= W-2) {
                pixel[0] = count; pixel[1] = it->second->at(0)[1] + 1;
                logger->fdebug("snsns", "Found at [", pixel[0], ", ", pixel[1], "]");
                return true;
        }
        count++;
    }
    logger->error("Cannot find an available pixel.");
    return false;
}

// Currently, we use one region. We need to record color difference which
// means we can't use _00.JPG train matrix.
// Definition of border pixels:
// If a pixel p on region R has a neighbor pixel p' such that p' is not on region R, then p is called a border pixel.
void region_builder::getAllBorderPixels(const cv::Mat& mat) {
    if (rows_map == nullptr || rows_map->size() == 0) {
        logger->info("Rows map not available.");
        return;
    }
    assert(H>1 && W>1);

    int s = 0;
    int r=0; int c=0;
    for (auto it=rows_map->begin(); it!=rows_map->end(); it++) {
        for (int i=0; i<it->second->size(); i++) {
            s = it->second->at(i)[1] - it->second->at(i)[0] + 1;
            for (int j=it->second->at(i)[0]; j<=it->second->at(i)[1]; j++) {
                r = it->first;
                c = j;
                logger->fdebug("snsn", "Get all border pixels. Current: Row: ", r, " Col: ", c);
                bitset x = bitset<8>(0); 
                // Scenarios on rows_map:
                //   Has p': If pixel p is span sp's lower bound pixel and p-col > 0; 
                //   Has p': If pixel p is span sp's upper bound pixel and p-col < mat.cols-1;
                if (j==0 && c>0) {
                    // Set nb_delta
                    x.set(static_cast<int>(direction::west), true);
                    checkNorth(r, c, x);
                    checkSouth(r, c, x);
                }
                else if (j==s-1 && c<W-1) {
                    // Set nb_delta
                    x.set(static_cast<int>(direction::east), true);
                    checkNorth(r, c, x);
                    checkSouth(r, c, x);
                } 
                else {
                    checkNorth(r, c, x);
                    checkSouth(r, c, x);
                }

                logger->debug("Border pixels: ", x.to_string());
                setBorderPixelsDiff(mat, r, c, x); 
            }
        }
    } 

    logger->info("bv size: ", bv->size());
}

void region_builder::checkNorth(int row, int col, bitset<8>& x) {
    //logger->debug("Check north.");
    if (row == 0) {
        return;
    }

    x.set(0, true);
    x.set(1, true);
    x.set(2, true);
    auto sch = rows_map->find(row-1);
    if (sch != rows_map->end()) {
        // All possible topn: 000, 010, etc.
        // No matter *sch->second contains (row-1, col) or not
        containsNorth(*sch->second, col, x);
        return;
    } 
}

// Brute force
void region_builder::containsNorth(const vector<int*>& v, int n, bitset<8>& x) {
    //logger->debug("contains north: ", n); cout << "current x: " << x.to_string() << endl;
    for (int i=0; i<v.size(); i++) {
        //printer->printVector(v, 2);

        // After bit shift: 0b11100000
        if (static_cast<unsigned char>(x.to_ulong() << 5) == 0) {
            return;
        }

        if (n > 0) {
            if (v.at(i)[0] <= n-1 && n-1 <= v.at(i)[1]) {
                x.set(static_cast<int>(direction::north_west), false);
            }
        }
        else {
           x.set(static_cast<int>(direction::north_west), false); 
        }

        if (v.at(i)[0] <= n && n <= v.at(i)[1]) {
            x.set(static_cast<int>(direction::north), false);
        }

        if (n < W-1) {
            if (v.at(i)[0] <= n+1 && n+1 <= v.at(i)[1]) {
                x.set(static_cast<int>(direction::north_east), false);
            }
        }
        else {
            x.set(static_cast<int>(direction::north_east), false);
        }
    }
}

void region_builder::checkSouth(int row, int col, bitset<8>& x) {
    if (row == H-1) {
        return;
    }

    x.set(4, true);
    x.set(5, true);
    x.set(6, true);
    auto sch = rows_map->find(row+1);
    if (sch != rows_map->end()) {
        // All possible topn: 000, 010, etc.
        // No matter *sch->second contains (row-1, col) or not
        containsSouth(*sch->second, col, x);
        return;
    }
}

void region_builder::containsSouth(const vector<int*>& v, int n, bitset<8>& x) {
    for (int i=0; i<v.size(); i++) {
        // After bit shift: 0b11100000
        if (static_cast<unsigned char>(x.to_ulong() << 1 >> 5) == 0) {
            return;
        }

        if (n > 0) {
            if (v.at(i)[0] <= n-1 && n-1 <= v.at(i)[1]) {
                x.set(static_cast<int>(direction::south_west), false);
            }
        }
        else {
           x.set(static_cast<int>(direction::south_west), false); 
        }
        
        if (v.at(i)[0] <= n && n <= v.at(i)[1]) {
            x.set(static_cast<int>(direction::south), false);
        }

        if (n < W-1) {
            if (v.at(i)[0] <= n+1 && n+1 <= v.at(i)[1]) {
                x.set(static_cast<int>(direction::south_east), false);
            }
        }
        else {
            x.set(static_cast<int>(direction::south_east), false);
        }
    }
}


void region_builder::setBorderPixelsDiff(const cv::Mat& mat, int row, int col, bitset<8>& x) {
    logger->fdebug("snsnsv", "Set border pixels diff. Current pixel: row: ", row, " col: ", col, " neighbors: ", x.to_string());
    if (static_cast<unsigned char>(x.to_ulong()) == 0) {
        logger->fdebug("snsn", "Pixel has no border. Row: ", row, " Col: ", col);
        count_internal++;
        return;
    }

    border_pixel_diff_node* bn = new border_pixel_diff_node();
    bn->index[0] = row;
    bn->index[1] = col;
    bn->x = x;
    if (row == 0) {
        if (col == 0) {
            // south, south_east, east
            if (x[static_cast<int>(direction::south)]) {
                setPixelDiff(mat, row, col, *bn, direction::south);
            }
            if (x[static_cast<int>(direction::south_east)]) {
                setPixelDiff(mat, row, col, *bn, direction::south_east);
            }
            if (x[static_cast<int>(direction::east)]) {
                setPixelDiff(mat, row, col, *bn, direction::east);
            }
        }
        else if (col == W-1) {
            // west, south_west, south
            if (x[static_cast<int>(direction::west)]) {
                setPixelDiff(mat, row, col, *bn, direction::west);
            }
            if (x[static_cast<int>(direction::south_west)]) {
                setPixelDiff(mat, row, col, *bn, direction::south_west);
            }
            if (x[static_cast<int>(direction::south)]) {
                setPixelDiff(mat, row, col, *bn, direction::south);
            }
        }
        else {
            // west, south_west, south, south_east, east
            if (x[static_cast<int>(direction::west)]) {
                setPixelDiff(mat, row, col, *bn, direction::west);
            }
            if (x[static_cast<int>(direction::south_west)]) {
                setPixelDiff(mat, row, col, *bn, direction::south_west);
            }
            if (x[static_cast<int>(direction::south)]) {
                setPixelDiff(mat, row, col, *bn, direction::south);
            }
            if (x[static_cast<int>(direction::south_east)]) {
                setPixelDiff(mat, row, col, *bn, direction::south_east);
            }
            if (x[static_cast<int>(direction::east)]) {
                setPixelDiff(mat, row, col, *bn, direction::east);
            }
        }
    }
    else if ( row == H - 1) {
        if ( col == 0) {
            // north, north_east, east
            if (x[static_cast<int>(direction::north)]) {
                setPixelDiff(mat, row, col, *bn, direction::north);
            }
            if (x[static_cast<int>(direction::north_east)]) {
                setPixelDiff(mat, row, col, *bn, direction::north_east);
            }
            if (x[static_cast<int>(direction::east)]) {
                setPixelDiff(mat, row, col, *bn, direction::east);
            }
        }
        else if (col == W-1) {
            // north, north_west, west
            if (x[static_cast<int>(direction::north)]) {
                setPixelDiff(mat, row, col, *bn, direction::north);
            }
            if (x[static_cast<int>(direction::north_west)]) {
                setPixelDiff(mat, row, col, *bn, direction::north_west);
            }
            if (x[static_cast<int>(direction::west)]) {
                setPixelDiff(mat, row, col, *bn, direction::west);
            }
        }
        else {
            // west, north_west, north, north_east, east
            if (x[static_cast<int>(direction::west)]) {
                setPixelDiff(mat, row, col, *bn, direction::west);
            }
            if (x[static_cast<int>(direction::north_west)]) {
                setPixelDiff(mat, row, col, *bn, direction::north_west);
            }
            if (x[static_cast<int>(direction::north)]) {
                setPixelDiff(mat, row, col, *bn, direction::north);
            }
            if (x[static_cast<int>(direction::north_east)]) {
                setPixelDiff(mat, row, col, *bn, direction::north_east);
            }
            if (x[static_cast<int>(direction::east)]) {
                setPixelDiff(mat, row, col, *bn, direction::east);
            }
        }
    }
    else {
        if ( col == 0) {
            // north, north_east, east, south_east, south
            if (x[static_cast<int>(direction::north)]) {
                setPixelDiff(mat, row, col, *bn, direction::north);
            }
            if (x[static_cast<int>(direction::north_east)]) {
                setPixelDiff(mat, row, col, *bn, direction::north_east);
            }
            if (x[static_cast<int>(direction::east)]) {
                setPixelDiff(mat, row, col, *bn, direction::east);
            }
            if (x[static_cast<int>(direction::south_east)]) {
                setPixelDiff(mat, row, col, *bn, direction::south_east);
            }
            if (x[static_cast<int>(direction::south)]) {
                setPixelDiff(mat, row, col, *bn, direction::south);
            }
        }
        else if (col == W-1) {
            // north, north_west, west, south_west, south
            if (x[static_cast<int>(direction::north)]) {
                setPixelDiff(mat, row, col, *bn, direction::north);
            }
            if (x[static_cast<int>(direction::north_west)]) {
                setPixelDiff(mat, row, col, *bn, direction::north_west);
            }
            if (x[static_cast<int>(direction::west)]) {
                setPixelDiff(mat, row, col, *bn, direction::west);
            }
            if (x[static_cast<int>(direction::south_west)]) {
                setPixelDiff(mat, row, col, *bn, direction::south_west);
            }
            if (x[static_cast<int>(direction::south)]) {
                setPixelDiff(mat, row, col, *bn, direction::south);
            }
        }
        else {
            // all
            if (x[static_cast<int>(direction::north_east)]) {
                setPixelDiff(mat, row, col, *bn, direction::north_east);
            }
            if (x[static_cast<int>(direction::north)]) {
                setPixelDiff(mat, row, col, *bn, direction::north);
            }
            if (x[static_cast<int>(direction::north_west)]) {
                setPixelDiff(mat, row, col, *bn, direction::north_west);
            }
            if (x[static_cast<int>(direction::west)]) {
                setPixelDiff(mat, row, col, *bn, direction::west);
            }
            if (x[static_cast<int>(direction::south_west)]) {
                setPixelDiff(mat, row, col, *bn, direction::south_west);
            }
            if (x[static_cast<int>(direction::south)]) {
                setPixelDiff(mat, row, col, *bn, direction::south);
            }
            if (x[static_cast<int>(direction::south_east)]) {
                setPixelDiff(mat, row, col, *bn, direction::south_east);
            }
            if (x[static_cast<int>(direction::east)]) {
                setPixelDiff(mat, row, col, *bn, direction::east);
            }
        }
    }
    bv->push_back(bn);
    //cout << "Set border pixel done. ";
    bn->print();
    cout << "Verify pixel. Row: " << row << " Col: " << col << " x: " << x.to_string() << endl;
    assert(verifyBorderPixels(*bn));
}

bool region_builder::verifyBorderPixels(const border_pixel_diff_node& bn) {
    for (int i=0; i<8; i++) {
        if (bn.diff[i][0] != 0 || bn.diff[i][1] != 0 || bn.diff[i][2] != 0) {
            return true;
        }
    }
    return false;
}

void region_builder::setPixelDiff(const cv::Mat& mat, int row, int col, border_pixel_diff_node& bn, direction dr) {
    // We don't assert here
    cv::Vec<unsigned char, 3> entry = mat.at<cv::Vec3b>(row, col);
    cv::Vec<unsigned char, 3> neighbor;
    
    switch (dr) {
        case direction::north_east:
            neighbor = mat.at<cv::Vec3b>(row-1, col+1);
            computeDelta(entry, neighbor, bn.diff[0]);
            return;
        case direction::north:
            neighbor = mat.at<cv::Vec3b>(row-1, col);
            computeDelta(entry, neighbor, bn.diff[1]);
            return;
        case direction::north_west:
            neighbor = mat.at<cv::Vec3b>(row-1, col-1);
            computeDelta(entry, neighbor, bn.diff[2]);
            return;
        case direction::west:
            neighbor = mat.at<cv::Vec3b>(row, col-1);
            computeDelta(entry, neighbor, bn.diff[3]);
            return;
        case direction::south_west:
            neighbor = mat.at<cv::Vec3b>(row+1, col-1);
            computeDelta(entry, neighbor, bn.diff[4]);
            return;
        case direction::south:
            neighbor = mat.at<cv::Vec3b>(row+1, col);
            computeDelta(entry, neighbor, bn.diff[5]);
            return;
        case direction::south_east:
            neighbor = mat.at<cv::Vec3b>(row+1, col+1);
            computeDelta(entry, neighbor, bn.diff[6]);
            return;
        case direction::east:
            neighbor = mat.at<cv::Vec3b>(row, col+1);
            computeDelta(entry, neighbor, bn.diff[7]);
            return;
        default:
            break;
    }
}

void region_builder::computeDelta(cv::Vec<unsigned char, 3>& entry, cv::Vec<unsigned char, 3>& neighbor, cv::Vec<int, 3>& df) {
    df[0] = static_cast<int>(entry[0]) - static_cast<int>(neighbor[0]);
    df[1] = static_cast<int>(entry[1]) - static_cast<int>(neighbor[1]);
    df[2] = static_cast<int>(entry[2]) - static_cast<int>(neighbor[2]);
}

void region_builder::printMapOnMatrix(const cv::Mat& mat) {
    cout << "Size of region: " << count << endl;
    printer->printMapOnMatrix(mat, *rows_map);
}

void region_builder::setRegionColorProvider(region_colors_provider* prov) {
    this->prov = prov;
}

void region_builder::getRegionColorsIndices(const cv::Mat& mat, std::vector<int*>* colorIndices, size_t t) {
    prov->getRegionColors(mat, *rows_map, colorIndices, t);
}

void region_builder::explore(simple_explore* sp, cv::Mat& mat, int row, int col) {
    if (mat.rows <= 0 || mat.cols <= 0) {
        logger->info("Invalid matrix.");
        return;
    }
    if (row < 0 || row >= mat.rows) {
        logger->info("Row out of bound: ", row);
        return;
    }
    if (col < 0 || col >= mat.cols) {
        logger->info("Col out of bound: ", col);
        return;
    }

    assert(po->getPolicy() == Policies::r_desc);
    logger->info("Explore: ", po->getPolicyVal());

    sta->clear();

    start = evaluator->evaluatePixelColor(*po, mat.at<cv::Vec3b>(row, col));
    logger->info("Start pixel desc: ", region_desc::toString(start));
    
    if ( start != po->getRegionDesc()) {
        logger->finfo("snsnsv", "Pixel not in region: row: ", row, " col: ", col, " for: ", po->getPolicyVal());
        return;
    }
    
    // Just cleared.
    if (cols_map == nullptr || rows_map == nullptr) {
        assert(cols == nullptr && rows == nullptr);
        init();
    }
    // Just used.
    else if (cols_map->size()>0 || rows_map->size()>0) {
        assert(cols->size()==0 || rows->size()==0);
        clear();
        init(); 
    }
    
    /// TODO
    H = mat.rows;
    W = mat.cols;
    mbounds->setOH(H);
    mbounds->setOW(W);
    
    this->sexp = sp;

    auto t1 = chrono::high_resolution_clock::now();

    /// TODO determine explore type here
    sexp->setRegionDesc(start);
    sexp->explore(mat, row, col, *rows, *cols, *rows_map, *cols_map);

    rpt->printMap("cols", *cols_map);
    rpt->printMap("rows", *rows_map);
    countRegionPixels();
    cout << "size: " << size() << endl;

    auto t2 = chrono::high_resolution_clock::now();
    logger->info("Total process time: ", (int)chrono::duration_cast<chrono::microseconds>(t2-t1).count());
}





