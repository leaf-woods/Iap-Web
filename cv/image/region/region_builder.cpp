#include <cassert>
#include <chrono>
#include <iostream>
#include "region_builder.h"

using namespace std;

/*
 * @20250912
 * A region has a property desc to indicate what is the region, e.g. the region is 
 * sky on the photo.
 */
 /// TODO test smallest region which is one pixel
 /*
  * @20250916
  * A region_builder builds regions using the image matrix according to the region desc.
  */
region_builder::region_builder() {
    init();
    sta = new bool_status(status::NORMAL, false);
}

region_builder::~region_builder() {
    logger->info("Destruct region builder.");
    clear();
    exp = nullptr;
    mbounds = nullptr;
    evaluator = nullptr;
    printer = nullptr;
    logger = nullptr;
    delete sta;
    sta = nullptr;
}

/*
 * Since region is reusable, clear() is not only called by destructor.
 */
void region_builder::clear() {
    if (sta != nullptr) {
        sta->clear();
    }
    
    // Just cleared.
    if (cols_map == nullptr || rows_map == nullptr || cols == nullptr || rows == nullptr) {
        return;
    }
    
    // Just created.
    if (cols_map->size()==0 && rows_map->size()==0 && cols->size()==0 && rows->size()==0) {
        delete cols_map; 
        cols_map = nullptr;
        delete rows_map; 
        rows_map = nullptr;
        delete cols; 
        cols = nullptr;
        delete rows; 
        rows = nullptr;
        assert(dv!=nullptr && dv->size()==0);
        delete dv;
        dv = nullptr;
        return;
    }

    // Just used.
    if (cols_map->size()>0) {
        clearMap(*cols_map);
    }
    *cols_map = map<int, std::vector<int*>*>();
    delete cols_map;
    cols_map = nullptr;

    if (rows_map->size()>0) {
        clearMap(*rows_map);
    }
    *rows_map = map<int, std::vector<int*>*>();
    delete rows_map;
    rows_map = nullptr;

    if (dv->size() > 0) {
        clearVector(*dv);
    }
    delete dv;
    dv = nullptr;

    //https://stackoverflow.com/questions/56688963/how-to-free-the-memory-occupied-by-a-queuestl
    if (cols->size()>0) {
        logger->error("Queue cols is not empty. Size: ", cols->size());
        cols->clear();
        deque<span_node*>().swap(*cols);
    }
    if (rows->size()>0) {
        logger->error("Queue rows is not empty. Size: ", rows->size());
        rows->clear();
        deque<span_node*>().swap(*rows);
    }
    delete rows;
    rows = nullptr;
    delete cols;
    cols = nullptr;
}

/*
 * vector<int*>: int* not generated by new.
 */
void region_builder::clearMap(map<int, vector<int*>*>& m) {
    if (m.size()>0) {
        vector<int*>* v;
        for (auto it=m.begin(); it!=m.end();) {
            v = it->second;
            v->clear(); 
            *v = vector<int*>();
            it = m.erase(it);
            delete v;
        }
    }
}

void region_builder::checkInBound(const cv::Mat& mat, int r, int c, bool_status& sta) {
    evaluator->evaluate(desc, mat.at<cv::Vec3b>(r, c), sta); 
}

void region_builder::countRegion() {
    if (rows_map->size()==0 || cols_map->size()==0) {
        assert(cols_map->size()==rows_map->size());
        logger->info("Map is empty.");
        return;
    }
    count = 0;
    if (rows_map->size() < cols_map->size()) {
        // https://en.cppreference.com/w/cpp/container/map.html
        for (const auto& [key, value] : *rows_map) {
            count+=countVector(*value);
        }
        
    }
    else {
        for (const auto& [key, value] : *cols_map) {
            count+=countVector(*value);
        }
    }
    logger->debug("size: ", count);
}

int region_builder::countVector(const vector<int*>& v) {
    int ct = 0;
    for (int i=0; i<v.size(); i++) {
        ct+=v.at(i)[1] - v.at(i)[0] + 1;
    }
    return ct;
}

void region_builder::init() {
    rows = new deque<span_node*>();
    cols = new deque<span_node*>();

    rows_map = new map<int, vector<int*>*>();
    cols_map = new map<int, vector<int*>*>();
    dv = new vector<int*>();
}

/*
 * @20250915 Reuse region.
 * Precondition: deque cols and rows, map cols_map and rows_map are newly created instances.
 */
void region_builder::explore(cv::Mat& mat, int row, int col) {
    if (mat.rows <= 0 || mat.cols <= 0) {
        logger->info("Invalid matrix.");
        return;
    }
    if (row < 0 || row >= mat.rows) {
        logger->info("Row out of bound: ", row);
        return;
    }
    if (col < 0 || col >= mat.cols) {
        logger->info("Col out of bound: ", col);
        return;
    }

    assert(desc > RegionDesc::na);
    logger->info("Explore: ", region_desc::toString(desc));

    sta->clear();
    checkInBound(mat, row, col, *sta);
    if (! sta->getResult()) {
        if (sta->isNormal()) {
            logger->finfo("snsnsv", "Pixel not in region: row: ", row, " col: ", col, " for: ", region_desc::toString(desc));
        }
        else {
            logger->error(sta->getMsg());
        }
        return;
    }
    
    // Just cleared.
    if (cols_map == nullptr || rows_map == nullptr) {
        assert(cols == nullptr && rows == nullptr);
        init();
    }
    // Just used.
    else if (cols_map->size()>0 || rows_map->size()>0) {
        assert(cols->size()==0 || rows->size()==0);
        clear();
        init(); 
    }
    
    H = mat.rows;
    W = mat.cols;
    mbounds->setOH(H);
    mbounds->setOW(W);
    
    auto t1 = chrono::high_resolution_clock::now();

    exp->setRegionDesc(desc);
    exp->explore(mat, row, col, *rows, *cols, *rows_map, *cols_map);

    //logger->fdebug("snsnsn", "count: ", count, " count col: ", count_exp_col, " count row: ", count_exp_row);

    rpt->printMap("cols", *cols_map);
    rpt->printMap("rows", *rows_map);
    countRegion();
    cout << "size: " << size() << endl;

    exp->explore_diag(mat, dv);

    auto t2 = chrono::high_resolution_clock::now();
    logger->info("Total process time: ", (int)chrono::duration_cast<chrono::microseconds>(t2-t1).count());
}

void region_builder::setLogger(iapcv_log* logger) {
    this->logger = logger;
}

void region_builder::setLogLevel(int level) {
    this->logger->setLevel(level);
}

void region_builder::setPrint(iap_print* print) {
    this->printer = print;
}

void region_builder::setRegionDesc(RegionDesc desc) {
    this->desc = desc;
}

void region_builder::setRegionEvaluator(region_evaluator* eval) {
    this->evaluator = eval;
}

void region_builder::setRegionExplore(region_explore* exp) {
    this->exp = exp;
}

void region_builder::setRegionPrint(region_print* p) {
    this->rpt = p;
}

int region_builder::size() {
    return count;
}

void region_builder::setMatrixBounds(matrix_bounds* mb) {
    this->mbounds = mb;
}

void region_builder::setSubMatrix(int r, int c, int num_rs, int num_cs) {
    mbounds->setSubMatrix(r, c, num_rs, num_cs);
}

void region_builder::useMatrix() {
    mbounds->useMatrix();
}

bool region_builder::getNextStartPoint(size_t s, int* pixel) {
    assert(s==2 && pixel != nullptr);
    if (rows_map == nullptr) {
        logger->error("Map is null.");
        return false;
    }
    if (rows_map->size() == 0) {
        logger->error("Map is empty.");
        return false;
    }
    int count = 0; 
    for (auto it=rows_map->begin(); it!=rows_map->end(); it++) {
        if (it->second->at(0)[0] >= 1) {
                pixel[0] = count; pixel[1] = it->second->at(0)[0] - 1;
                logger->fdebug("snsns", "Found at [", pixel[0], ", ", pixel[1], "]");
                return true;
        }
        if (it->second->at(0)[1] <= W-2) {
                pixel[0] = count; pixel[1] = it->second->at(0)[1] + 1;
                logger->fdebug("snsns", "Found at [", pixel[0], ", ", pixel[1], "]");
                return true;
        }
        count++;
    }
    logger->error("Cannot find an available pixel.");
    return false;
}





