#include <cassert>
#include <iostream>
#include <opencv2/core.hpp>
#include "hsvtree.h"

using namespace std;

int main(int argc, char* argv[]) {

    uchar data[5][3] = { {255, 255, 255}, 
                     {255, 0, 0},
                     {128, 128, 128},
                     {0, 0, 0},
                     {220, 255, 255}
                    };

    int max = 0;
    iap_print* p = new iap_print();

    cout << "Test-1 hsvtree" << endl;
    hsvtree t;
    t.setPrint(p);

    uchar hsv[] = {255, 255, 255};
    t.add(hsv);
    assert(255==t.getMaxValue());
    t.printTree();
    t.deleteTree();
    cout << "Test-1 hsvtree: Done." << endl;
    cout << endl;

    cout << "Test-2 hsvtree" << endl;
    t.add(data[1]);
    assert(1==t.size());
    assert(255==t.getMaxValue());
    t.printTree();
    cout << "Test-2 hsvtree: Done." << endl;
    cout << endl;

    cout << "Test-3 hsvtree" << endl;
    t.add(data[2]);
    assert(2==t.size());
    assert(255==t.getMaxValue());
    t.printTree();
    cout << "Test-3 hsvtree: Done." << endl;
    cout << endl;

    cout << "Test-4 hsvtree" << endl;
    t.add(data[0]);
    t.add(data[3]);
    t.add(data[4]);
    assert(4==t.size());
    assert(255==t.getMaxValue());
    t.printTree();
    cout << "Test-4 hsvtree: Done." << endl;
    cout << endl;

    t.deleteTree();
    assert(0==t.size());

    /*
     * Added findNode(N* n, int data) in ibstree.h
     * Added findValues(N* n, int data) in htree.cpp
     *
     * Test use result generated by case: img64/IMG_4585_S_CR_R1_S64_00.JPG in test_img_data.test_img_data_blue()
     * Re-construct the hstree.
     */
    cout << "Test-5 hsvtree" << endl;
    uchar data_00 [44][3] = { {108, 170, 147} , {108, 161, 149} , {108, 157, 145} , {108, 172, 145} , {108, 157, 149} , {108, 160, 150} , {108, 164, 146} , {108, 171, 146} , {108, 168, 143} , {108, 160, 147} , {108, 159, 146} , {108, 161, 146} , {108, 160, 145} , {108, 165, 145} , {108, 162, 145} , {108, 161, 144} , {108, 162, 148} , {108, 163, 142} , {108, 159, 148} , {108, 158, 147} , {108, 163, 147} , {108, 153, 148} , {108, 155, 150} , {108, 174, 144} , {108, 175, 143} , {108, 153, 152} , {108, 176, 142} , {108, 166, 144} , {108, 155, 146} , {108, 157, 148} , {108, 146, 159} , {108, 147, 158} , {108, 145, 156} , {108, 145, 157} , {108, 154, 147} , {108, 156, 149} , {108, 151, 154} , {108, 152, 149} , {108, 154, 151} , {108, 141, 161} , {108, 144, 158} , {108, 150, 151} , {108, 152, 153} , {108, 150, 155}  };
    for (int i=0; i<44; i++) {
        t.add(data_00[i]);
    }
    assert(1==t.size());

    uchar data_00_2 [158][3] = { {109, 174, 144}, {109, 138, 161}, {109, 137, 160}, {109, 137, 158}, {109, 138, 159}, {109, 136, 157}, {109, 141, 157}, {109, 140, 158}, {109, 131, 160}, {109, 127, 156}, {109, 135, 155}, {109, 135, 162}, {109, 132, 159}, {109, 134, 164}, {109, 127, 157}, {109, 172, 148}, {109, 169, 145}, {109, 163, 150}, {109, 159, 146}, {109, 156, 155}, {109, 153, 152}, {109, 151, 150}, {109, 160, 151}, {109, 161, 152}, {109, 155, 146}, {109, 157, 148}, {109, 171, 146}, {109, 167, 142}, {109, 161, 150}, {109, 158, 147}, {109, 168, 149}, {109, 164, 145}, {109, 170, 144}, {109, 173, 147}, {109, 165, 151}, {109, 158, 144}, {109, 161, 147}, {109, 158, 153}, {109, 155, 150}, {109, 153, 148}, {109, 168, 152}, {109, 164, 148}, {109, 162, 146}, {109, 159, 152}, {109, 160, 153}, {109, 154, 147}, {109, 156, 149}, {109, 169, 148}, {109, 165, 144}, {109, 169, 151}, {109, 165, 147}, {109, 160, 145}, {109, 164, 149}, {109, 171, 149}, {109, 167, 145}, {109, 168, 146}, {109, 164, 152}, {109, 155, 143}, {109, 157, 145}, {109, 160, 148}, {109, 170, 150}, {109, 167, 147}, {109, 166, 146}, {109, 167, 150}, {109, 165, 148}, {109, 175, 146}, {109, 157, 154}, {109, 154, 151}, {109, 152, 149}, {109, 152, 146}, {109, 157, 151}, {109, 153, 147}, {109, 151, 145}, {109, 176, 145}, {109, 177, 144}, {109, 152, 153}, {109, 150, 151}, {109, 150, 148}, {109, 149, 147}, {109, 151, 149}, {109, 178, 143}, {109, 170, 147}, {109, 166, 143}, {109, 154, 144}, {109, 159, 149}, {109, 142, 154}, {109, 145, 157}, {109, 143, 155}, {109, 143, 153}, {109, 144, 154}, {109, 145, 156}, {109, 144, 151}, {109, 147, 154}, {109, 153, 145}, {109, 158, 150}, {109, 154, 146}, {109, 152, 144}, {109, 146, 154}, {109, 145, 153}, {109, 144, 152}, {109, 141, 155}, {109, 138, 152}, {109, 142, 156}, {109, 144, 158}, {109, 148, 153}, {109, 146, 148}, {109, 148, 150}, {109, 147, 149}, {109, 149, 151}, {109, 156, 152}, {109, 152, 148}, {109, 150, 146}, {109, 149, 145}, {109, 151, 147}, {109, 140, 159}, {109, 138, 157}, {109, 139, 158}, {109, 137, 156}, {109, 134, 156}, {109, 136, 158}, {109, 140, 153}, {109, 141, 156}, {109, 139, 154}, {109, 140, 157}, {109, 139, 156}, {109, 138, 155}, {109, 142, 151}, {109, 146, 155}, {109, 143, 152}, {109, 144, 150}, {109, 147, 153}, {109, 145, 151}, {109, 146, 152}, {109, 154, 154}, {109, 150, 150}, {109, 149, 149}, {109, 148, 148}, {109, 151, 154}, {109, 149, 152}, {109, 136, 161}, {109, 135, 160}, {109, 134, 162}, {109, 133, 161}, {109, 132, 158}, {109, 134, 160}, {109, 124, 160}, {109, 125, 159}, {109, 152, 156}, {109, 146, 150}, {109, 148, 152}, {109, 147, 151}, {109, 129, 162}, {109, 126, 158}, {109, 133, 157}, {109, 135, 159}, {109, 124, 161}, {109, 122, 163}, {109, 130, 161}  };
    for (int i=0; i<158; i++) {
        t.add(data_00_2[i]);
    }
    assert(2==t.size());

    uchar data_00_3 [22][3] = { {110, 164, 151}, {110, 149, 145}, {110, 161, 154}, {110, 163, 152}, {110, 142, 153}, {110, 143, 152}, {110, 162, 153}, {110, 144, 151}, {110, 141, 154}, {110, 157, 158}, {110, 136, 154}, {110, 158, 157}, {110, 146, 148}, {110, 133, 157}, {110, 131, 156}, {110, 121, 162}, {110, 127, 161}, {110, 129, 162}, {110, 128, 160}, {110, 130, 161}, {110, 132, 155}, {110, 126, 162}  };
    /// TODO 
    // https://stackoverflow.com/questions/14309877/calculate-number-of-rows-in-constant-2d-c-array
    /** No index bound check. If we write i<44, assertion failed. */
    for (int i=0; i<22; i++) {
        t.add(data_00_3[i]);
    }
    assert(3==t.size());

    vector<uchar*>* vec = t.findValues(108);
    assert(vec);

    vec = t.findValues(0);
    assert(!vec);

    vec = t.findValues(109);
    cout << "vec size: " << vec->size() << endl;
    assert(vec->size()==158);

    vector<int>* vh = new vector<int>();
    t.getTreeData(vh);
    assert(3==vh->size());

    for (auto it=(*vh).begin(); it!=(*vh).end(); it++) {
        cout << "H: " << (*it) << endl;
    }
    delete vh;
    cout << "Test-5 hsvtree: Done." << endl;
    cout << endl;

    delete p;
    p = nullptr;
    return 0;
}